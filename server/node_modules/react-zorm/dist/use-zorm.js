"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useZorm = void 0;
const react_1 = require("react");
const chains_1 = require("./chains");
const parse_form_1 = require("./parse-form");
function useZorm(formName, schema, options) {
    const formRef = (0, react_1.useRef)();
    const submittedOnceRef = (0, react_1.useRef)(false);
    const submitRef = (0, react_1.useRef)(options?.onValidSubmit);
    submitRef.current = options?.onValidSubmit;
    const formDataRef = (0, react_1.useRef)(options?.onFormData);
    formDataRef.current = options?.onFormData;
    const [validation, setValidation] = (0, react_1.useState)(null);
    const getForm = (0, react_1.useCallback)(() => {
        if (!formRef.current) {
            throw new Error("[react-zorm]: Form ref not passed");
        }
        return formRef.current;
    }, []);
    const validate = (0, react_1.useCallback)(() => {
        const res = (0, parse_form_1.safeParseForm)(schema, getForm());
        setValidation(res);
        return res;
    }, [getForm, schema]);
    const changeHandler = (0, react_1.useCallback)(() => {
        if (!submittedOnceRef.current) {
            return;
        }
        validate();
    }, [validate]);
    const formdataHandler = (0, react_1.useCallback)((event) => {
        formDataRef.current?.(event);
    }, []);
    const submitHandler = (0, react_1.useCallback)((e) => {
        submittedOnceRef.current = true;
        const validation = validate();
        if (!validation.success) {
            e.preventDefault();
        }
        else {
            submitRef.current?.({
                data: validation.data,
                target: getForm(),
                preventDefault: () => {
                    e.preventDefault();
                },
            });
        }
    }, [getForm, validate]);
    const invalidHandler = (0, react_1.useCallback)(() => {
        submittedOnceRef.current = true;
        validate();
    }, [validate]);
    const callbackRef = (0, react_1.useCallback)((form) => {
        if (form !== formRef.current) {
            if (formRef.current) {
                const off = formRef.current.removeEventListener.bind(formRef.current);
                off("change", changeHandler);
                off("submit", submitHandler);
                off("invalid", invalidHandler, false);
                off("formdata", formdataHandler);
            }
            if (form && options?.setupListeners !== false) {
                form.addEventListener("change", changeHandler);
                form.addEventListener("submit", submitHandler);
                form.addEventListener("formdata", formdataHandler);
                // The form does not submit when it is invalid due to html5
                // attributes (ex. required, min, max, etc.). So detect
                // invalid form state with the "invalid" event and run our
                // own validation on it too.
                form.addEventListener("invalid", invalidHandler, 
                // "invalid" event does not bubble so listen on capture
                // phase by setting capture to true
                true);
            }
            formRef.current = form ?? undefined;
        }
    }, [
        options?.setupListeners,
        changeHandler,
        submitHandler,
        invalidHandler,
        formdataHandler,
    ]);
    return (0, react_1.useMemo)(() => {
        let customIssues = options?.customIssues ?? [];
        let error = !validation?.success ? validation?.error : undefined;
        const allIssues = [...(error?.issues ?? []), ...customIssues];
        const errors = (0, chains_1.errorChain)(schema, allIssues);
        const fields = (0, chains_1.fieldChain)(formName, schema, allIssues);
        return {
            ref: callbackRef,
            refObject: formRef,
            validate,
            get form() {
                return formRef.current;
            },
            validation,
            fields,
            errors,
            customIssues: customIssues,
        };
    }, [
        callbackRef,
        formName,
        options?.customIssues,
        schema,
        validate,
        validation,
    ]);
}
exports.useZorm = useZorm;
//# sourceMappingURL=use-zorm.js.map