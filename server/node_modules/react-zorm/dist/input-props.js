"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inputProps = void 0;
const zod_1 = require("zod");
function removeZodEffects(type) {
    // remove .refine() etc.
    if (type instanceof zod_1.ZodEffects) {
        return removeZodEffects(type.innerType());
    }
    return type;
}
function stringCheckProps(type) {
    const checks = type._def.checks;
    const props = {
        type: "text",
    };
    for (const check of checks) {
        if (check.kind === "min") {
            props.minLength = check.value;
        }
        if (check.kind === "max") {
            props.maxLength = check.value;
        }
        if (check.kind === "regex") {
            props.pattern = check.regex.toString().slice(1, -1);
        }
        if (check.kind === "email") {
            props.type = "email";
        }
        // TODO the rest...
    }
    return props;
}
function numberCheckProps(type) {
    const checks = type._def.checks;
    const props = {
        type: "number",
        step: "any",
    };
    for (const check of checks) {
        if (check.kind === "min") {
            props.min = check.value;
        }
        if (check.kind === "max") {
            props.max = check.value;
        }
        if (check.kind === "int" && props.step === "any") {
            // defaults to 1 so we can remove it if limited to ints
            delete props.step;
        }
        if (check.kind === "multipleOf") {
            props.step = check.value;
        }
    }
    return props;
}
function dateCheckProps(type) {
    const checks = type._def.checks;
    const props = {
        type: "date",
    };
    for (const check of checks) {
        if (check.kind === "min") {
            props.min = check.value;
        }
        if (check.kind === "max") {
            props.max = check.value;
        }
    }
    return props;
}
function collectProps(type, _props = {}) {
    const props = _props ?? {};
    type = removeZodEffects(type);
    if (type instanceof zod_1.ZodDefault) {
        props.defaultValue = type._def.defaultValue();
    }
    else if (type instanceof zod_1.ZodOptional || type instanceof zod_1.ZodNullable) {
        props.required = false;
    }
    else if (type instanceof zod_1.ZodString) {
        Object.assign(props, stringCheckProps(type));
    }
    else if (type instanceof zod_1.ZodNumber) {
        Object.assign(props, numberCheckProps(type));
    }
    else if (type instanceof zod_1.ZodDate) {
        Object.assign(props, dateCheckProps(type));
    }
    // Remove optional/nullable wrapping etc. There's probably a better way to do this.
    const anyType = type;
    if (anyType._def?.innerType) {
        return collectProps(anyType._def.innerType, props);
    }
    return props;
}
function inputProps(field) {
    const props = {
        type: "text",
        required: true,
        ...collectProps(field.type),
        name: field.name,
    };
    if (props.required === false) {
        delete props.required;
    }
    if (field.issues.length > 0) {
        props["aria-invalid"] = true;
        props["aria-errormessage"] = field.errorId;
    }
    return props;
}
exports.inputProps = inputProps;
//# sourceMappingURL=input-props.js.map