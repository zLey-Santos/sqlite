"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCustomIssues = exports.errorChain = exports.fieldChain = void 0;
const zod_1 = require("zod");
const zod_2 = require("zod");
const utils_1 = require("./utils");
function addArrayIndex(path, index) {
    const last = path[path.length - 1];
    return [...path.slice(0, -1), `${last}[${index}]`];
}
function unwrapZodType(type) {
    if (type instanceof zod_2.z.ZodObject || type instanceof zod_2.z.ZodArray) {
        return type;
    }
    if (type instanceof zod_2.z.ZodEffects) {
        return unwrapZodType(type.innerType());
    }
    const anyType = type;
    if (anyType._def?.innerType) {
        return unwrapZodType(anyType._def.innerType);
    }
    return type;
}
function fieldChain(ns, schema, issues) {
    return new Proxy({}, {
        get(_target, prop) {
            return _fieldChain(ns, schema, issues, [])[prop];
        },
    });
}
exports.fieldChain = fieldChain;
function _fieldChain(ns, schema, issues, path) {
    const proxy = new Proxy(() => { }, {
        apply(_target, _thisArg, args) {
            if (typeof args[0] === "number") {
                const unwrapped = unwrapZodType(schema);
                if (!(unwrapped instanceof zod_1.ZodArray)) {
                    throw new Error(`Expected ZodArray at "${path.join(".")}" got ${schema.constructor.name}`);
                }
                return _fieldChain(ns, unwrapped.element, issues, addArrayIndex(path, args[0]));
            }
            const name = path.join(".");
            const id = ns + ":" + path.join(".");
            if (args[0] === "id") {
                return id;
            }
            const errorId = "error:" + id;
            if (args[0] === "errorid") {
                return errorId;
            }
            if (typeof args[0] === "function") {
                const matching = issues.filter((issue) => {
                    return (0, utils_1.arrayEquals)(issue.path, path);
                });
                const props = {
                    id,
                    name,
                    type: schema,
                    issues: matching,
                    errorId,
                };
                return args[0](props);
            }
            return name;
        },
        get(_target, prop) {
            if (typeof prop !== "string") {
                throw new Error("Unexpected string property: " + String(prop));
            }
            const unwrapped = unwrapZodType(schema);
            if (!(unwrapped instanceof zod_1.ZodObject)) {
                throw new Error(`Expected ZodObject at "${path.join(".")}" got ${schema.constructor.name}`);
            }
            return _fieldChain(ns, unwrapped.shape[prop], issues, [
                ...path,
                prop,
            ]);
        },
    });
    return proxy;
}
function errorChain(schema, issues, _path) {
    let path = _path || [];
    const proxy = new Proxy(() => { }, {
        apply(_target, _thisArg, args) {
            if (typeof args[0] === "number") {
                return errorChain(schema, issues, [...path, args[0]]);
            }
            const matching = issues.filter((issue) => {
                return (0, utils_1.arrayEquals)(issue.path, path);
            });
            const hasError = matching.length > 0;
            // Ex. zo.error.field(Boolean)
            if (args[0] === Boolean) {
                return Boolean(hasError);
            }
            // Ex. zo.error.field(error => error.message)
            if (typeof args[0] === "function") {
                if (hasError) {
                    return args[0](...matching);
                }
                return undefined;
            }
            // Return itself when there is an error
            // Ex. className={zo.error.field("errored")}
            if (args[0]) {
                if (hasError) {
                    return args[0];
                }
                else {
                    return undefined;
                }
            }
            // without args return the first error if any
            return matching[0];
        },
        get(_target, prop) {
            if (typeof prop === "string") {
                return errorChain(schema, issues, [...path, prop]);
            }
            return errorChain(schema, issues, path);
        },
    });
    return proxy;
}
exports.errorChain = errorChain;
function createCustomIssues(schema, _state) {
    const state = _state
        ? _state
        : {
            path: [],
            issues: [],
        };
    /**
     * Methods that are available at the chain root
     */
    const methods = {
        toJSON: () => state.issues.slice(0),
        toArray: () => state.issues.slice(0),
        hasIssues: () => state.issues.length > 0,
    };
    const proxy = new Proxy(() => { }, {
        apply(_target, _thisArg, args) {
            if (typeof args[0] === "number") {
                return createCustomIssues(schema, {
                    ...state,
                    path: [...state.path, args[0]],
                });
            }
            const issue = {
                code: "custom",
                path: state.path,
                message: args[0],
                params: args[1] ?? {},
            };
            state.issues.push(issue);
            return issue;
        },
        get(_target, prop) {
            if (state.path.length === 0 && prop in methods) {
                return methods[prop];
            }
            if (typeof prop === "string") {
                return createCustomIssues(schema, {
                    ...state,
                    path: [...state.path, prop],
                });
            }
            return createCustomIssues(schema, state);
        },
    });
    return proxy;
}
exports.createCustomIssues = createCustomIssues;
//# sourceMappingURL=chains.js.map