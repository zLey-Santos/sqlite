import { ZodArray, ZodObject, z, ZodDefault, ZodOptional, ZodNullable, ZodString, ZodNumber, ZodDate, ZodEffects } from "zod";
import { useRef, useState, useCallback, useMemo, useEffect } from "react";
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
const stringToPath = (string) => {
  const result = [];
  if (string.charCodeAt(0) === charCodeOfDot) {
    result.push("");
  }
  string.replace(rePropName, (match, expression, quote, subString) => {
    let key = match;
    if (quote) {
      key = subString.replace(reEscapeChar, "$1");
    } else if (expression) {
      key = expression.trim();
    }
    result.push(key);
    return "";
  });
  return result;
};
const keysCache = {};
const toPath = (key) => {
  if (key === null || key === void 0 || !key.length) {
    return [];
  }
  if (typeof key !== "string") {
    throw new Error("toPath() expects a string");
  }
  if (keysCache[key] == null) {
    keysCache[key] = stringToPath(key);
  }
  return keysCache[key];
};
const setInRecursor = (current, index, path, value, destroyArrays) => {
  if (index >= path.length) {
    return value;
  }
  const key = path[index];
  if (isNaN(key)) {
    if (current === void 0 || current === null) {
      const result3 = setInRecursor(
        void 0,
        index + 1,
        path,
        value,
        destroyArrays
      );
      return result3 === void 0 ? void 0 : { [key]: result3 };
    }
    if (Array.isArray(current)) {
      throw new Error("Cannot set a non-numeric property on an array");
    }
    const result2 = setInRecursor(
      current[key],
      index + 1,
      path,
      value,
      destroyArrays
    );
    if (result2 === void 0) {
      const numKeys = Object.keys(current).length;
      if (current[key] === void 0 && numKeys === 0) {
        return void 0;
      }
      if (current[key] !== void 0 && numKeys <= 1) {
        if (!isNaN(path[index - 1]) && !destroyArrays) {
          return {};
        } else {
          return void 0;
        }
      }
      const { [key]: _removed, ...final } = current;
      return final;
    }
    return {
      ...current,
      [key]: result2
    };
  }
  const numericKey = Number(key);
  if (current === void 0 || current === null) {
    const result2 = setInRecursor(
      void 0,
      index + 1,
      path,
      value,
      destroyArrays
    );
    if (result2 === void 0) {
      return void 0;
    }
    const array2 = [];
    array2[numericKey] = result2;
    return array2;
  }
  if (!Array.isArray(current)) {
    throw new Error("Cannot set a numeric property on an object");
  }
  const existingValue = current[numericKey];
  const result = setInRecursor(
    existingValue,
    index + 1,
    path,
    value,
    destroyArrays
  );
  const array = [...current];
  if (destroyArrays && result === void 0) {
    array.splice(numericKey, 1);
    if (array.length === 0) {
      return void 0;
    }
  } else {
    array[numericKey] = result;
  }
  return array;
};
const setIn = (state, key, value) => {
  if (state === void 0 || state === null) {
    throw new Error(`Cannot call setIn() with ${String(state)} state`);
  }
  if (key === void 0 || key === null) {
    throw new Error(`Cannot call setIn() with ${String(key)} key`);
  }
  return setInRecursor(state, 0, toPath(key), value, false);
};
function fixHoles(ob) {
  if (Array.isArray(ob)) {
    const array = ob;
    for (let index = 0, length = array.length; index < length; index++) {
      if (!(index in array)) {
        array[index] = void 0;
      } else {
        fixHoles(array[index]);
      }
    }
  }
  if (ob === null) {
    return;
  }
  if (typeof ob === "object") {
    for (const value of Object.values(ob)) {
      fixHoles(value);
    }
  }
}
function parseFormAny(form) {
  let data;
  if ("onsubmit" in form) {
    data = new FormData(form);
  } else {
    data = form;
  }
  let ret = {};
  for (const [key, value] of data.entries()) {
    ret = setIn(ret, key, value);
  }
  fixHoles(ret);
  return ret;
}
function parseForm(schema, form) {
  return schema.parse(parseFormAny(form));
}
function safeParseForm(schema, form) {
  return schema.safeParse(parseFormAny(form));
}
function isValuedElement(input) {
  return input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement || input instanceof HTMLSelectElement;
}
function arrayEquals(a, b) {
  return a.length === b.length && a.every((item, index) => {
    return item === b[index];
  });
}
function addArrayIndex(path, index) {
  const last = path[path.length - 1];
  return [...path.slice(0, -1), `${last}[${index}]`];
}
function unwrapZodType(type) {
  if (type instanceof z.ZodObject || type instanceof z.ZodArray) {
    return type;
  }
  if (type instanceof z.ZodEffects) {
    return unwrapZodType(type.innerType());
  }
  const anyType = type;
  if (anyType._def?.innerType) {
    return unwrapZodType(anyType._def.innerType);
  }
  return type;
}
function fieldChain(ns, schema, issues) {
  return new Proxy(
    {},
    {
      get(_target, prop) {
        return _fieldChain(ns, schema, issues, [])[prop];
      }
    }
  );
}
function _fieldChain(ns, schema, issues, path) {
  const proxy = new Proxy(() => {
  }, {
    apply(_target, _thisArg, args) {
      if (typeof args[0] === "number") {
        const unwrapped = unwrapZodType(schema);
        if (!(unwrapped instanceof ZodArray)) {
          throw new Error(
            `Expected ZodArray at "${path.join(".")}" got ${schema.constructor.name}`
          );
        }
        return _fieldChain(
          ns,
          unwrapped.element,
          issues,
          addArrayIndex(path, args[0])
        );
      }
      const name = path.join(".");
      const id = ns + ":" + path.join(".");
      if (args[0] === "id") {
        return id;
      }
      const errorId = "error:" + id;
      if (args[0] === "errorid") {
        return errorId;
      }
      if (typeof args[0] === "function") {
        const matching = issues.filter((issue) => {
          return arrayEquals(issue.path, path);
        });
        const props = {
          id,
          name,
          type: schema,
          issues: matching,
          errorId
        };
        return args[0](props);
      }
      return name;
    },
    get(_target, prop) {
      if (typeof prop !== "string") {
        throw new Error("Unexpected string property: " + String(prop));
      }
      const unwrapped = unwrapZodType(schema);
      if (!(unwrapped instanceof ZodObject)) {
        throw new Error(
          `Expected ZodObject at "${path.join(".")}" got ${schema.constructor.name}`
        );
      }
      return _fieldChain(ns, unwrapped.shape[prop], issues, [
        ...path,
        prop
      ]);
    }
  });
  return proxy;
}
function errorChain(schema, issues, _path) {
  let path = _path || [];
  const proxy = new Proxy(() => {
  }, {
    apply(_target, _thisArg, args) {
      if (typeof args[0] === "number") {
        return errorChain(schema, issues, [...path, args[0]]);
      }
      const matching = issues.filter((issue) => {
        return arrayEquals(issue.path, path);
      });
      const hasError = matching.length > 0;
      if (args[0] === Boolean) {
        return Boolean(hasError);
      }
      if (typeof args[0] === "function") {
        if (hasError) {
          return args[0](...matching);
        }
        return void 0;
      }
      if (args[0]) {
        if (hasError) {
          return args[0];
        } else {
          return void 0;
        }
      }
      return matching[0];
    },
    get(_target, prop) {
      if (typeof prop === "string") {
        return errorChain(schema, issues, [...path, prop]);
      }
      return errorChain(schema, issues, path);
    }
  });
  return proxy;
}
function createCustomIssues(schema, _state) {
  const state = _state ? _state : {
    path: [],
    issues: []
  };
  const methods = {
    toJSON: () => state.issues.slice(0),
    toArray: () => state.issues.slice(0),
    hasIssues: () => state.issues.length > 0
  };
  const proxy = new Proxy(() => {
  }, {
    apply(_target, _thisArg, args) {
      if (typeof args[0] === "number") {
        return createCustomIssues(schema, {
          ...state,
          path: [...state.path, args[0]]
        });
      }
      const issue = {
        code: "custom",
        path: state.path,
        message: args[0],
        params: args[1] ?? {}
      };
      state.issues.push(issue);
      return issue;
    },
    get(_target, prop) {
      if (state.path.length === 0 && prop in methods) {
        return methods[prop];
      }
      if (typeof prop === "string") {
        return createCustomIssues(schema, {
          ...state,
          path: [...state.path, prop]
        });
      }
      return createCustomIssues(schema, state);
    }
  });
  return proxy;
}
function useZorm(formName, schema, options) {
  const formRef = useRef();
  const submittedOnceRef = useRef(false);
  const submitRef = useRef(options?.onValidSubmit);
  submitRef.current = options?.onValidSubmit;
  const formDataRef = useRef(options?.onFormData);
  formDataRef.current = options?.onFormData;
  const [validation, setValidation] = useState(null);
  const getForm = useCallback(() => {
    if (!formRef.current) {
      throw new Error("[react-zorm]: Form ref not passed");
    }
    return formRef.current;
  }, []);
  const validate = useCallback(() => {
    const res = safeParseForm(schema, getForm());
    setValidation(res);
    return res;
  }, [getForm, schema]);
  const changeHandler = useCallback(() => {
    if (!submittedOnceRef.current) {
      return;
    }
    validate();
  }, [validate]);
  const formdataHandler = useCallback((event) => {
    formDataRef.current?.(event);
  }, []);
  const submitHandler = useCallback(
    (e) => {
      submittedOnceRef.current = true;
      const validation2 = validate();
      if (!validation2.success) {
        e.preventDefault();
      } else {
        submitRef.current?.({
          data: validation2.data,
          target: getForm(),
          preventDefault: () => {
            e.preventDefault();
          }
        });
      }
    },
    [getForm, validate]
  );
  const invalidHandler = useCallback(() => {
    submittedOnceRef.current = true;
    validate();
  }, [validate]);
  const callbackRef = useCallback(
    (form) => {
      if (form !== formRef.current) {
        if (formRef.current) {
          const off = formRef.current.removeEventListener.bind(
            formRef.current
          );
          off("change", changeHandler);
          off("submit", submitHandler);
          off("invalid", invalidHandler, false);
          off("formdata", formdataHandler);
        }
        if (form && options?.setupListeners !== false) {
          form.addEventListener("change", changeHandler);
          form.addEventListener("submit", submitHandler);
          form.addEventListener("formdata", formdataHandler);
          form.addEventListener(
            "invalid",
            invalidHandler,
            // "invalid" event does not bubble so listen on capture
            // phase by setting capture to true
            true
          );
        }
        formRef.current = form ?? void 0;
      }
    },
    [
      options?.setupListeners,
      changeHandler,
      submitHandler,
      invalidHandler,
      formdataHandler
    ]
  );
  return useMemo(() => {
    let customIssues = options?.customIssues ?? [];
    let error = !validation?.success ? validation?.error : void 0;
    const allIssues = [...error?.issues ?? [], ...customIssues];
    const errors = errorChain(schema, allIssues);
    const fields = fieldChain(formName, schema, allIssues);
    return {
      ref: callbackRef,
      refObject: formRef,
      validate,
      get form() {
        return formRef.current;
      },
      validation,
      fields,
      errors,
      customIssues
    };
  }, [
    callbackRef,
    formName,
    options?.customIssues,
    schema,
    validate,
    validation
  ]);
}
function useValue(opts) {
  const [value, setValue] = useState(opts.initialValue ?? "");
  const mapRef = useRef(opts.transform);
  useEffect(() => {
    const form = opts.zorm.refObject.current;
    if (!form) {
      return;
    }
    const listener = (e) => {
      const input = e.target;
      if (!isValuedElement(input)) {
        return;
      }
      if (opts.name !== input.name) {
        return;
      }
      if (mapRef.current) {
        setValue(mapRef.current(input.value));
      } else {
        setValue(input.value ?? "");
      }
    };
    const initialInput = form.querySelector(`[name="${opts.name}"]`);
    if (initialInput) {
      listener({ target: initialInput });
    }
    const event = opts.event ?? "input";
    form.addEventListener(event, listener);
    return () => {
      form.removeEventListener(event, listener);
    };
  }, [opts.name, opts.zorm.refObject, opts.event]);
  return value;
}
function Value(props) {
  const value = useValue(props);
  return props.children(value);
}
function removeZodEffects(type) {
  if (type instanceof ZodEffects) {
    return removeZodEffects(type.innerType());
  }
  return type;
}
function stringCheckProps(type) {
  const checks = type._def.checks;
  const props = {
    type: "text"
  };
  for (const check of checks) {
    if (check.kind === "min") {
      props.minLength = check.value;
    }
    if (check.kind === "max") {
      props.maxLength = check.value;
    }
    if (check.kind === "regex") {
      props.pattern = check.regex.toString().slice(1, -1);
    }
    if (check.kind === "email") {
      props.type = "email";
    }
  }
  return props;
}
function numberCheckProps(type) {
  const checks = type._def.checks;
  const props = {
    type: "number",
    step: "any"
  };
  for (const check of checks) {
    if (check.kind === "min") {
      props.min = check.value;
    }
    if (check.kind === "max") {
      props.max = check.value;
    }
    if (check.kind === "int" && props.step === "any") {
      delete props.step;
    }
    if (check.kind === "multipleOf") {
      props.step = check.value;
    }
  }
  return props;
}
function dateCheckProps(type) {
  const checks = type._def.checks;
  const props = {
    type: "date"
  };
  for (const check of checks) {
    if (check.kind === "min") {
      props.min = check.value;
    }
    if (check.kind === "max") {
      props.max = check.value;
    }
  }
  return props;
}
function collectProps(type, _props = {}) {
  const props = _props ?? {};
  type = removeZodEffects(type);
  if (type instanceof ZodDefault) {
    props.defaultValue = type._def.defaultValue();
  } else if (type instanceof ZodOptional || type instanceof ZodNullable) {
    props.required = false;
  } else if (type instanceof ZodString) {
    Object.assign(props, stringCheckProps(type));
  } else if (type instanceof ZodNumber) {
    Object.assign(props, numberCheckProps(type));
  } else if (type instanceof ZodDate) {
    Object.assign(props, dateCheckProps(type));
  }
  const anyType = type;
  if (anyType._def?.innerType) {
    return collectProps(anyType._def.innerType, props);
  }
  return props;
}
function inputProps(field) {
  const props = {
    type: "text",
    required: true,
    ...collectProps(field.type),
    name: field.name
  };
  if (props.required === false) {
    delete props.required;
  }
  if (field.issues.length > 0) {
    props["aria-invalid"] = true;
    props["aria-errormessage"] = field.errorId;
  }
  return props;
}
export {
  Value,
  createCustomIssues,
  errorChain,
  fieldChain,
  parseForm,
  parseFormAny,
  safeParseForm,
  inputProps as unstable_inputProps,
  useValue,
  useZorm
};
//# sourceMappingURL=react-zorm.mjs.map
