{"version":3,"file":"react-zorm.mjs","sources":["../src/set-in.ts","../src/parse-form.ts","../src/utils.ts","../src/chains.tsx","../src/use-zorm.tsx","../src/use-value.ts","../src/input-props.ts"],"sourcesContent":["/**\n * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js\n * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE\n * Copyright (c) 2017 Erik Rasmussen\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Based on Underscore.js, copyright Jeremy Ashkenas,\n *\n * Structure Tester\n * https://8ypq7n41z0.codesandbox.io/\n */\n\ntype State = any;\n\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    \"[^.[\\\\]]+\" +\n        \"|\" +\n        // Or match property names within brackets.\n        \"\\\\[(?:\" +\n        // Match a non-string expression.\n        \"([^\\\"'][^[]*)\" +\n        \"|\" +\n        // Or match strings (supports escaping characters).\n        \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" +\n        \")\\\\]\" +\n        \"|\" +\n        // Or match \"\" as the space between consecutive dots or empty brackets.\n        \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\",\n    \"g\",\n);\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nconst stringToPath = (string: string) => {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push(\"\");\n    }\n    string.replace(rePropName, (match, expression, quote, subString) => {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, \"$1\");\n        } else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n\n        return \"\";\n    });\n    return result;\n};\n\nconst keysCache: { [key: string]: string[] } = {};\n\nconst toPath = (key: string): string[] => {\n    if (key === null || key === undefined || !key.length) {\n        return [];\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(\"toPath() expects a string\");\n    }\n\n    if (keysCache[key] == null) {\n        keysCache[key] = stringToPath(key);\n    }\n    return keysCache[key]!;\n};\n\nconst setInRecursor = (\n    current: State,\n    index: number,\n    path: string[],\n    value: any,\n    destroyArrays: boolean,\n): State => {\n    if (index >= path.length) {\n        // end of recursion\n        return value;\n    }\n    const key = path[index]!;\n\n    // determine type of key\n    if (isNaN(key as any)) {\n        // object set\n        if (current === undefined || current === null) {\n            // recurse\n            const result = setInRecursor(\n                undefined,\n                index + 1,\n                path,\n                value,\n                destroyArrays,\n            );\n\n            // delete or create an object\n            return result === undefined ? undefined : { [key]: result };\n        }\n        if (Array.isArray(current)) {\n            throw new Error(\"Cannot set a non-numeric property on an array\");\n        }\n        // current exists, so make a copy of all its values, and add/update the new one\n        const result = setInRecursor(\n            current[key],\n            index + 1,\n            path,\n            value,\n            destroyArrays,\n        );\n        if (result === undefined) {\n            const numKeys = Object.keys(current).length;\n            if (current[key] === undefined && numKeys === 0) {\n                // object was already empty\n                return undefined;\n            }\n            if (current[key] !== undefined && numKeys <= 1) {\n                // only key we had was the one we are deleting\n                if (!isNaN(path[index - 1] as any) && !destroyArrays) {\n                    // we are in an array, so return an empty object\n                    return {};\n                } else {\n                    return undefined;\n                }\n            }\n            const { [key]: _removed, ...final } = current;\n            return final;\n        }\n        // set result in key\n        return {\n            ...current,\n            [key]: result,\n        };\n    }\n    // array set\n    const numericKey = Number(key);\n    if (current === undefined || current === null) {\n        // recurse\n        const result = setInRecursor(\n            undefined,\n            index + 1,\n            path,\n            value,\n            destroyArrays,\n        );\n\n        // if nothing returned, delete it\n        if (result === undefined) {\n            return undefined;\n        }\n\n        // create an array\n        const array = [];\n        array[numericKey] = result;\n        return array as any[];\n    }\n    if (!Array.isArray(current)) {\n        throw new Error(\"Cannot set a numeric property on an object\");\n    }\n    // recurse\n    const existingValue = current[numericKey];\n    const result = setInRecursor(\n        existingValue,\n        index + 1,\n        path,\n        value,\n        destroyArrays,\n    );\n\n    // current exists, so make a copy of all its values, and add/update the new one\n    const array = [...current];\n    if (destroyArrays && result === undefined) {\n        array.splice(numericKey, 1);\n        if (array.length === 0) {\n            return undefined;\n        }\n    } else {\n        array[numericKey] = result;\n    }\n    return array;\n};\n\nexport const setIn = (state: {}, key: string, value: any): any => {\n    if (state === undefined || state === null) {\n        throw new Error(`Cannot call setIn() with ${String(state)} state`);\n    }\n    if (key === undefined || key === null) {\n        throw new Error(`Cannot call setIn() with ${String(key)} key`);\n    }\n    // Recursive function needs to accept and return State, but public API should\n    // only deal with Objects\n    return setInRecursor(state, 0, toPath(key), value, false) as any;\n};\n","import { SafeParseReturnType } from \"zod\";\nimport { setIn } from \"./set-in\";\nimport { GenericSchema } from \"./types\";\n\n/**\n * Fix sparse array from nested objects. Puts undefineds to array holes.\n */\nfunction fixHoles(ob: object | any[]) {\n    if (Array.isArray(ob)) {\n        const array = ob;\n        for (let index = 0, length = array.length; index < length; index++) {\n            if (!(index in array)) {\n                array[index] = undefined;\n            } else {\n                fixHoles(array[index]);\n            }\n        }\n    }\n\n    if (ob === null) {\n        return;\n    }\n\n    if (typeof ob === \"object\") {\n        for (const value of Object.values(ob)) {\n            fixHoles(value);\n        }\n    }\n}\n\n/**\n * Parse nested data from a form element or a FormData object.\n *\n * Ex. <input name=\"ding[0].dong\" value=\"value\" />\n *\n *     =>  { ding: [ {dong: \"value\"} ] }\n *\n * Inspired by Final Form. See https://8ypq7n41z0.codesandbox.io/\n */\nexport function parseFormAny(form: HTMLFormElement | FormData) {\n    let data: FormData;\n    if (\"onsubmit\" in form) {\n        data = new FormData(form);\n    } else {\n        data = form;\n    }\n\n    let ret: any = {};\n\n    for (const [key, value] of data.entries()) {\n        ret = setIn(ret, key, value);\n    }\n\n    // Remove sparse arrays as Zod does not like them.\n    // XXX Should probably just fix setIn() to avoid sparse arrays.\n    fixHoles(ret);\n\n    return ret;\n}\n\nexport function parseForm<P extends GenericSchema>(\n    schema: P,\n    form: HTMLFormElement | FormData,\n): ReturnType<P[\"parse\"]> {\n    return schema.parse(parseFormAny(form));\n}\n\nexport function safeParseForm<P extends GenericSchema>(\n    schema: P,\n    form: HTMLFormElement | FormData,\n): SafeParseReturnType<any, ReturnType<P[\"parse\"]>> {\n    return schema.safeParse(parseFormAny(form));\n}\n","export function isValuedElement(\n    input: any,\n): input is HTMLInputElement | HTMLTextAreaElement {\n    return (\n        input instanceof HTMLInputElement ||\n        input instanceof HTMLTextAreaElement ||\n        input instanceof HTMLSelectElement\n    );\n}\n\nexport function arrayEquals(a: readonly any[], b: readonly any[]) {\n    return (\n        a.length === b.length &&\n        a.every((item, index) => {\n            return item === b[index];\n        })\n    );\n}\n","import { ZodArray, ZodCustomIssue, ZodIssue, ZodObject, ZodType } from \"zod\";\nimport { z } from \"zod\";\nimport {\n    ErrorChainFromSchema,\n    ErrorGetter,\n    FieldChainFromSchema,\n    IssueCreatorFromSchema,\n    IssueCreatorMethods,\n    RenderProps,\n    ZodCustomIssueWithMessage,\n} from \"./types\";\nimport { arrayEquals } from \"./utils\";\n\nfunction addArrayIndex(path: readonly string[], index: number) {\n    const last = path[path.length - 1];\n    return [...path.slice(0, -1), `${last}[${index}]`];\n}\n\nfunction unwrapZodType(type: ZodType): ZodType {\n    if (type instanceof z.ZodObject || type instanceof z.ZodArray) {\n        return type;\n    }\n\n    if (type instanceof z.ZodEffects) {\n        return unwrapZodType(type.innerType());\n    }\n\n    const anyType = type as any;\n    if (anyType._def?.innerType) {\n        return unwrapZodType(anyType._def.innerType);\n    }\n\n    return type;\n}\n\nexport function fieldChain<Schema extends ZodType>(\n    ns: string,\n    schema: Schema,\n    issues: ZodIssue[],\n): FieldChainFromSchema<Schema> {\n    return new Proxy(\n        {},\n        {\n            get(_target, prop) {\n                return _fieldChain(ns, schema, issues, [])[prop];\n            },\n        },\n    ) as any;\n}\n\nfunction _fieldChain(\n    ns: string,\n    schema: ZodType,\n    issues: ZodIssue[],\n    path: readonly string[],\n) {\n    const proxy: any = new Proxy(() => {}, {\n        apply(_target, _thisArg, args) {\n            if (typeof args[0] === \"number\") {\n                const unwrapped = unwrapZodType(schema);\n                if (!(unwrapped instanceof ZodArray)) {\n                    throw new Error(\n                        `Expected ZodArray at \"${path.join(\".\")}\" got ${\n                            schema.constructor.name\n                        }`,\n                    );\n                }\n\n                return _fieldChain(\n                    ns,\n                    unwrapped.element,\n                    issues,\n                    addArrayIndex(path, args[0]),\n                );\n            }\n\n            const name = path.join(\".\");\n            const id = ns + \":\" + path.join(\".\");\n\n            if (args[0] === \"id\") {\n                return id;\n            }\n\n            const errorId = \"error:\" + id;\n\n            if (args[0] === \"errorid\") {\n                return errorId;\n            }\n\n            if (typeof args[0] === \"function\") {\n                const matching = issues.filter((issue) => {\n                    return arrayEquals(issue.path, path);\n                });\n\n                const props: RenderProps = {\n                    id,\n                    name,\n                    type: schema,\n                    issues: matching,\n                    errorId,\n                };\n\n                return args[0](props);\n            }\n\n            return name;\n        },\n\n        get(_target, prop) {\n            if (typeof prop !== \"string\") {\n                throw new Error(\"Unexpected string property: \" + String(prop));\n            }\n\n            const unwrapped = unwrapZodType(schema);\n            if (!(unwrapped instanceof ZodObject)) {\n                throw new Error(\n                    `Expected ZodObject at \"${path.join(\".\")}\" got ${\n                        schema.constructor.name\n                    }`,\n                );\n            }\n\n            return _fieldChain(ns, unwrapped.shape[prop], issues, [\n                ...path,\n                prop,\n            ]);\n        },\n    });\n\n    return proxy;\n}\n\nexport function errorChain<Schema extends ZodType>(\n    schema: Schema,\n    issues: ZodIssue[],\n    _path?: readonly (string | number)[],\n): ErrorChainFromSchema<Schema> & ErrorGetter {\n    let path = _path || [];\n    const proxy: any = new Proxy(() => {}, {\n        apply(_target, _thisArg, args) {\n            if (typeof args[0] === \"number\") {\n                return errorChain(schema, issues, [...path, args[0]]);\n            }\n\n            const matching = issues.filter((issue) => {\n                return arrayEquals(issue.path, path);\n            });\n            const hasError = matching.length > 0;\n\n            // Ex. zo.error.field(Boolean)\n            if (args[0] === Boolean) {\n                return Boolean(hasError);\n            }\n\n            // Ex. zo.error.field(error => error.message)\n            if (typeof args[0] === \"function\") {\n                if (hasError) {\n                    return args[0](...matching);\n                }\n\n                return undefined;\n            }\n\n            // Return itself when there is an error\n            // Ex. className={zo.error.field(\"errored\")}\n            if (args[0]) {\n                if (hasError) {\n                    return args[0];\n                } else {\n                    return undefined;\n                }\n            }\n\n            // without args return the first error if any\n            return matching[0];\n        },\n\n        get(_target, prop) {\n            if (typeof prop === \"string\") {\n                return errorChain(schema, issues, [...path, prop]);\n            }\n\n            return errorChain(schema, issues, path);\n        },\n    });\n\n    return proxy;\n}\n\nexport function createCustomIssues<Schema extends ZodType>(\n    schema: Schema,\n    _state?: {\n        path: (string | number)[];\n        issues: ZodCustomIssueWithMessage[];\n    },\n): IssueCreatorFromSchema<Schema> {\n    const state = _state\n        ? _state\n        : {\n              path: [],\n              issues: [],\n          };\n\n    /**\n     * Methods that are available at the chain root\n     */\n    const methods: IssueCreatorMethods = {\n        toJSON: () => state.issues.slice(0),\n        toArray: () => state.issues.slice(0),\n        hasIssues: () => state.issues.length > 0,\n    };\n\n    const proxy: any = new Proxy(() => {}, {\n        apply(_target, _thisArg, args) {\n            if (typeof args[0] === \"number\") {\n                return createCustomIssues(schema, {\n                    ...state,\n                    path: [...state.path, args[0]],\n                });\n            }\n\n            const issue: ZodCustomIssueWithMessage = {\n                code: \"custom\",\n                path: state.path,\n                message: args[0],\n                params: args[1] ?? {},\n            };\n\n            state.issues.push(issue);\n\n            return issue;\n        },\n\n        get(_target, prop) {\n            if (state.path.length === 0 && prop in methods) {\n                return (methods as any)[prop];\n            }\n\n            if (typeof prop === \"string\") {\n                return createCustomIssues(schema, {\n                    ...state,\n                    path: [...state.path, prop],\n                });\n            }\n\n            return createCustomIssues(schema, state);\n        },\n    });\n\n    return proxy;\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport {\n    ZodType,\n    ZodError,\n    ZodCustomIssue,\n    ZodIssue,\n    SafeParseReturnType,\n} from \"zod\";\nimport { errorChain, fieldChain } from \"./chains\";\nimport { safeParseForm } from \"./parse-form\";\nimport type { Zorm } from \"./types\";\n\nexport interface ValidSubmitEvent<Data> {\n    /**\n     * Prevent the default form submission\n     */\n    preventDefault(): void;\n\n    /**\n     * The form HTML Element\n     */\n    target: HTMLFormElement;\n\n    /**\n     * Zod validated and parsed data\n     */\n    data: Data;\n}\n\nexport interface UseZormOptions<Data extends SafeParseReturnType<any, any>> {\n    /**\n     * Called when the form is submitted with valid data\n     */\n    onValidSubmit?: (event: ValidSubmitEvent<Data>) => any;\n\n    setupListeners?: boolean;\n\n    customIssues?: ZodIssue[];\n\n    onFormData?: (event: FormDataEvent) => any;\n}\n\nexport function useZorm<Schema extends ZodType<any>>(\n    formName: string,\n    schema: Schema,\n    options?: UseZormOptions<ReturnType<Schema[\"parse\"]>>,\n): Zorm<Schema> {\n    type ValidationResult = SafeParseReturnType<\n        any,\n        ReturnType<Schema[\"parse\"]>\n    >;\n\n    const formRef = useRef<HTMLFormElement>();\n    const submittedOnceRef = useRef(false);\n    const submitRef = useRef<\n        UseZormOptions<ReturnType<Schema[\"parse\"]>>[\"onValidSubmit\"] | undefined\n    >(options?.onValidSubmit);\n    submitRef.current = options?.onValidSubmit;\n\n    const formDataRef = useRef<\n        UseZormOptions<ReturnType<Schema[\"parse\"]>>[\"onFormData\"] | undefined\n    >(options?.onFormData);\n    formDataRef.current = options?.onFormData;\n\n    const [validation, setValidation] = useState<ValidationResult | null>(null);\n\n    const getForm = useCallback(() => {\n        if (!formRef.current) {\n            throw new Error(\"[react-zorm]: Form ref not passed\");\n        }\n        return formRef.current;\n    }, []);\n\n    const validate = useCallback(() => {\n        const res = safeParseForm(schema, getForm());\n        setValidation(res);\n        return res;\n    }, [getForm, schema]);\n\n    const changeHandler = useCallback(() => {\n        if (!submittedOnceRef.current) {\n            return;\n        }\n\n        validate();\n    }, [validate]);\n\n    const formdataHandler = useCallback((event: FormDataEvent) => {\n        formDataRef.current?.(event);\n    }, []);\n\n    const submitHandler = useCallback(\n        (e: { preventDefault(): any }) => {\n            submittedOnceRef.current = true;\n            const validation = validate();\n\n            if (!validation.success) {\n                e.preventDefault();\n            } else {\n                submitRef.current?.({\n                    data: validation.data,\n                    target: getForm(),\n                    preventDefault: () => {\n                        e.preventDefault();\n                    },\n                });\n            }\n        },\n        [getForm, validate],\n    );\n\n    const invalidHandler = useCallback(() => {\n        submittedOnceRef.current = true;\n        validate();\n    }, [validate]);\n\n    const callbackRef = useCallback(\n        (form: HTMLFormElement | null) => {\n            if (form !== formRef.current) {\n                if (formRef.current) {\n                    const off = formRef.current.removeEventListener.bind(\n                        formRef.current,\n                    );\n\n                    off(\"change\", changeHandler);\n                    off(\"submit\", submitHandler);\n                    off(\"invalid\", invalidHandler, false);\n                    off(\"formdata\", formdataHandler);\n                }\n\n                if (form && options?.setupListeners !== false) {\n                    form.addEventListener(\"change\", changeHandler);\n                    form.addEventListener(\"submit\", submitHandler);\n                    form.addEventListener(\"formdata\", formdataHandler);\n\n                    // The form does not submit when it is invalid due to html5\n                    // attributes (ex. required, min, max, etc.). So detect\n                    // invalid form state with the \"invalid\" event and run our\n                    // own validation on it too.\n                    form.addEventListener(\n                        \"invalid\",\n                        invalidHandler,\n                        // \"invalid\" event does not bubble so listen on capture\n                        // phase by setting capture to true\n                        true,\n                    );\n                }\n                formRef.current = form ?? undefined;\n            }\n        },\n        [\n            options?.setupListeners,\n            changeHandler,\n            submitHandler,\n            invalidHandler,\n            formdataHandler,\n        ],\n    );\n\n    return useMemo(() => {\n        let customIssues = options?.customIssues ?? [];\n        let error = !validation?.success ? validation?.error : undefined;\n\n        const allIssues = [...(error?.issues ?? []), ...customIssues];\n\n        const errors = errorChain(schema, allIssues);\n        const fields = fieldChain(formName, schema, allIssues);\n\n        return {\n            ref: callbackRef,\n            refObject: formRef,\n            validate,\n            get form() {\n                return formRef.current;\n            },\n            validation,\n            fields,\n            errors,\n            customIssues: customIssues,\n        };\n    }, [\n        callbackRef,\n        formName,\n        options?.customIssues,\n        schema,\n        validate,\n        validation,\n    ]);\n}\n","import { RefObject, useEffect, useRef, useState } from \"react\";\nimport { isValuedElement } from \"./utils\";\n\nexport interface ValueSubscription<T> {\n    name: string;\n    zorm: {\n        refObject: React.MutableRefObject<HTMLFormElement | undefined>;\n    };\n    initialValue?: T;\n    event?: string;\n    transform?: (value: string) => T;\n}\n\nexport function useValue<T>(\n    opts: ValueSubscription<T>,\n): undefined extends T ? string : T {\n    const [value, setValue] = useState<any>(opts.initialValue ?? \"\");\n    const mapRef = useRef<((value: string) => T) | undefined>(opts.transform);\n\n    useEffect(() => {\n        const form = opts.zorm.refObject.current;\n        if (!form) {\n            return;\n        }\n\n        const listener = (e: { target: {} | null }) => {\n            const input = e.target;\n\n            if (!isValuedElement(input)) {\n                return;\n            }\n\n            if (opts.name !== input.name) {\n                return;\n            }\n\n            if (mapRef.current) {\n                setValue(mapRef.current(input.value));\n            } else {\n                setValue(input.value ?? \"\");\n            }\n        };\n\n        const initialInput = form.querySelector(`[name=\"${opts.name}\"]`);\n\n        if (initialInput) {\n            listener({ target: initialInput });\n        }\n\n        const event = opts.event ?? \"input\";\n\n        form.addEventListener(event, listener);\n        return () => {\n            form.removeEventListener(event, listener);\n        };\n    }, [opts.name, opts.zorm.refObject, opts.event]);\n\n    return value;\n}\n\nexport function Value<T>(\n    props: ValueSubscription<T> & {\n        children: (value: undefined extends T ? string : T) => any;\n    },\n) {\n    const value = useValue(props);\n    return props.children(value);\n}\n","import {\n    ZodType,\n    ZodEffects,\n    ZodString,\n    ZodNumber,\n    ZodDate,\n    ZodDefault,\n    ZodOptional,\n    ZodNullable,\n} from \"zod\";\nimport { RenderProps } from \".\";\n\nexport interface InputProps {\n    type: string;\n    name: string;\n    required?: boolean;\n    min?: number;\n    max?: number;\n    minLength?: number;\n    maxLength?: number;\n    pattern?: string;\n    step?: string | number;\n    defaultValue?: string | number;\n    [\"aria-invalid\"]?: boolean;\n    [\"aria-errormessage\"]?: string;\n}\n\nfunction removeZodEffects(type: ZodType): ZodType {\n    // remove .refine() etc.\n    if (type instanceof ZodEffects) {\n        return removeZodEffects(type.innerType());\n    }\n\n    return type;\n}\n\nfunction stringCheckProps(type: ZodString) {\n    const checks = type._def.checks;\n\n    const props: Partial<InputProps> = {\n        type: \"text\",\n    };\n\n    for (const check of checks) {\n        if (check.kind === \"min\") {\n            props.minLength = check.value;\n        }\n\n        if (check.kind === \"max\") {\n            props.maxLength = check.value;\n        }\n\n        if (check.kind === \"regex\") {\n            props.pattern = check.regex.toString().slice(1, -1);\n        }\n\n        if (check.kind === \"email\") {\n            props.type = \"email\";\n        }\n\n        // TODO the rest...\n    }\n\n    return props;\n}\n\nfunction numberCheckProps(type: ZodNumber) {\n    const checks = type._def.checks;\n\n    const props: Partial<InputProps> = {\n        type: \"number\",\n        step: \"any\",\n    };\n\n    for (const check of checks) {\n        if (check.kind === \"min\") {\n            props.min = check.value;\n        }\n\n        if (check.kind === \"max\") {\n            props.max = check.value;\n        }\n\n        if (check.kind === \"int\" && props.step === \"any\") {\n            // defaults to 1 so we can remove it if limited to ints\n            delete props.step;\n        }\n\n        if (check.kind === \"multipleOf\") {\n            props.step = check.value;\n        }\n    }\n\n    return props;\n}\n\nfunction dateCheckProps(type: ZodDate) {\n    const checks = type._def.checks;\n\n    const props: Partial<InputProps> = {\n        type: \"date\",\n    };\n\n    for (const check of checks) {\n        if (check.kind === \"min\") {\n            props.min = check.value;\n        }\n\n        if (check.kind === \"max\") {\n            props.max = check.value;\n        }\n    }\n\n    return props;\n}\n\nfunction collectProps(\n    type: ZodType,\n    _props: Partial<InputProps> = {},\n): Partial<InputProps> {\n    const props = _props ?? {};\n\n    type = removeZodEffects(type);\n\n    if (type instanceof ZodDefault) {\n        props.defaultValue = type._def.defaultValue();\n    } else if (type instanceof ZodOptional || type instanceof ZodNullable) {\n        props.required = false;\n    } else if (type instanceof ZodString) {\n        Object.assign(props, stringCheckProps(type));\n    } else if (type instanceof ZodNumber) {\n        Object.assign(props, numberCheckProps(type));\n    } else if (type instanceof ZodDate) {\n        Object.assign(props, dateCheckProps(type));\n    }\n\n    // Remove optional/nullable wrapping etc. There's probably a better way to do this.\n    const anyType = type as any;\n    if (anyType._def?.innerType) {\n        return collectProps(anyType._def.innerType, props);\n    }\n\n    return props;\n}\n\nexport function inputProps(field: RenderProps): InputProps {\n    const props: InputProps = {\n        type: \"text\",\n        required: true,\n        ...collectProps(field.type),\n        name: field.name,\n    };\n\n    if (props.required === false) {\n        delete props.required;\n    }\n\n    if (field.issues.length > 0) {\n        props[\"aria-invalid\"] = true;\n        props[\"aria-errormessage\"] = field.errorId;\n    }\n\n    return props;\n}\n"],"names":["result","array","validation"],"mappings":"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"}